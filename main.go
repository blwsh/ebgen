package main

import (
	"archive/zip"
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/schemas"
)

var svc = schemas.New(
	session.Must(session.NewSessionWithOptions(session.Options{})),
)

func main() {
	var (
		ctx              = context.Background()
		arn, out         = os.Args[1], os.Args[2]
		schemaNamePrefix = arn[strings.LastIndex(arn, "/")+1:]
	)

	registryStartIndex := 0
	if strings.Index(os.Args[1], "arn:aws:schemas:") == 0 {
		registryStartIndex = strings.Index(arn, "/") + 1

	}
	registryName := arn[registryStartIndex:strings.LastIndex(arn, "/")]

	if out == "" {
		out = "."
	} else if _, err := os.Stat(out); !os.IsNotExist(err) {
		if err := os.MkdirAll(out, 0775); err != nil {
			fmt.Printf("error creating output directory: %v\n", err)
			return
		}
	}

	result, err := svc.ListSchemasWithContext(ctx, &schemas.ListSchemasInput{
		RegistryName:     &registryName,
		SchemaNamePrefix: &schemaNamePrefix,
	})
	if err != nil {
		panic(err)
	}

	var exactMatch *schemas.SchemaSummary

	for _, schema := range result.Schemas {
		if *schema.SchemaName == schemaNamePrefix {
			exactMatch = schema
			break
		}
	}

	if exactMatch != nil {
		err = svc.WaitUntilCodeBindingExistsWithContext(ctx, &schemas.DescribeCodeBindingInput{
			Language:     aws.String("Go1"),
			RegistryName: &registryName,
			SchemaName:   &schemaNamePrefix,
		})
		if err != nil {
			fmt.Printf("error waiting for code bindings to be ready for schema %s: %v\n", schemaNamePrefix, err)
			return
		}

		codeBindingSource, err := svc.GetCodeBindingSourceWithContext(ctx, &schemas.GetCodeBindingSourceInput{
			Language:     aws.String("Go1"),
			RegistryName: &registryName,
			SchemaName:   &schemaNamePrefix,
		})
		if err != nil {
			fmt.Printf("error getting code bindings for schema %s: %v\n", schemaNamePrefix, err)
			return
		}

		// extract the code binding content
		reader := bytes.NewReader(codeBindingSource.Body)
		zipReader, err := zip.NewReader(reader, int64(len(codeBindingSource.Body)))
		if err != nil {
			fmt.Printf("error reading zip content for schema %s: %v\n", schemaNamePrefix, err)
			return
		}

		for _, file := range zipReader.File {
			if !strings.HasPrefix(file.Name, "schema/") {
				continue
			}
			name := strings.TrimPrefix(file.Name, "schema/")
			if name == "" {
				continue
			}
			filePath := filepath.Join(out, name)
			if file.FileInfo().IsDir() {
				os.MkdirAll(filePath, os.ModePerm)
				continue
			}

			if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
				fmt.Printf("error creating directory for file %s: %v\n", file.Name, err)
				return
			}

			outFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
			if err != nil {
				fmt.Printf("error creating file %s: %v\n", file.Name, err)
				return
			}

			rc, err := file.Open()
			if err != nil {
				fmt.Printf("error opening file in zip %s: %v\n", file.Name, err)
				return
			}

			// Write generated file comment
			_, err = outFile.WriteString("// Code generated by ebgen. DO NOT EDIT.\n\n")
			if err != nil {
				fmt.Printf("error writing generated comment to file %s: %v\n", file.Name, err)
				return
			}

			_, err = io.Copy(outFile, rc)
			if err != nil {
				fmt.Printf("error writing file %s: %v\n", file.Name, err)
				return
			}

			outFile.Close()
			rc.Close()
		}

		fmt.Printf("Code bindings for schema %s extracted to %s\n", schemaNamePrefix, out)
	}
}
